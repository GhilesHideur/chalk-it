{
  "meta": {
    "version": "3.000.8720",
    "fileFormatVersion": "0.3",
    "date": "Wed Nov 15 2023 21:24:13 GMT+0100 (heure normale d\u2019Europe centrale)",
    "name": "MBG_tests",
    "description": "",
    "groupName": "",
    "tags": [],
    "schedulerLogOff": true
  },
  "data": {
    "datanodes": [
      {
        "name": "a",
        "type": "JSON_var_plugin",
        "settings": {
          "name": "a",
          "json_var": "{\"type\":\"\",\"size\":10892,\"name\":\"plot-selection.md\",\"content\":\"# Select and Filter data\\r\\n\\r\\n**Selection** and **Filter** are important tools in interactive data analysis and visualisation.\\r\\n\\r\\nWith Plotly JavaScript generic graph, the xDash platform gives you access to selected events which contain all fields necessary in order to use selected element in the dataflow (transfer selection to another graph, filter data according to selection,  ...) \\r\\n\\r\\n>For those familiar with Plotly select events, \\\"appendix I\\\" will explain how xDash selection events are created. \\r\\n\\r\\n## main data and global index\\r\\n\\r\\nWhen user wants to create a graph from a selection of another graph, or to transfer the selection from one graph to another (or from one graph to a script), there is a logic of a main shared data.\\r\\n\\r\\nThis could be the result of a CSV import, a global JSON or GeoJSON.\\r\\n\\r\\nThis shared data is considered and referenced as the global data in our exemples and will be present in the dataNode [data].\\r\\n\\r\\nEach global shared data is indexed (In the CSV exemple, the index is the lane of each datum) and we will use the term \\\"global index\\\" as a generic expression to reference this main indexation. \\r\\n\\r\\n\\r\\n## How to use the selection from a graph to draw another one\\r\\n\\r\\nFirst example :\\r\\n\\r\\n* [selection-example-1.xprjson](/wdg/selection/selection-example-1.xprjson)\\r\\n\\r\\nIn this first exemple we :  \\r\\n\\r\\n - Plot all data in one scatter plot graph (Plotly Generic)\\r\\n - Recover the selection from the scatter \\r\\n - Build an histogram using only the selected data\\r\\n\\r\\nThe main data is an array of datum that each contains 3 values [Alpha, Beta, Delta]. Typically obtained from a CSV import. The cross plot will be done between [alpha vs beta] and [delta] will be used to draw the histogram.\\r\\n\\r\\n![example-1-graph](graph.png)\\r\\n\\r\\n\\r\\nThe dataFlow contains 5 dataNodes and 2 associated widgets\\r\\n\\r\\n - One DataNode that contains the global data.\\r\\n - Two DataNodes are created for each Plotly Graph (data and layout)\\r\\n - One DataNode which contains the selection\\r\\n - One widget [plotly generic] is the scatter plot \\r\\n - One widget  [plotly generic] is the histogram \\r\\n \\r\\nThe data for the Plotly histogram is dependant of the selection DataNode.\\r\\n\\r\\n>The graphs and DataNodes associated (PloltlyData and PlotlyLayout) dont know each others and dont have direct relationship. \\r\\n\\r\\nIn order to have a clean change in the histogram,  the X axis limit and bin limits are defined via all the data. \\r\\n\\r\\n## How to draw a graph with different sources of selection\\r\\n\\r\\nNow, lets imagine that what you want to draw is defined by the addition of different incoming selections.\\r\\n\\r\\nExample 2:\\r\\n\\r\\n* [selection-example-2.xprjson](/wdg/selection/selection-example-2.xprjson)\\r\\n\\r\\nIn Exemple 2 \\r\\n\\r\\n - We draw 2 scatter plots \\r\\n - Both selection are used to draw the histogram.\\r\\n\\r\\nThis exemple is similar than the last one except that :\\r\\n\\r\\n - the selection datanode has now one field for each cross plot selection\\r\\n - one dataNode is now present to process the selection [MultiSelectionProcess]\\r\\n\\r\\nThe process node does the addition of each selection.\\r\\n\\r\\nThe structure of the selection node has changed, there is now one field for each graph which will aggregate their selection.\\r\\n\\r\\nEach selection actuator from the cross plot now is now linked with one field of the selection node.\\r\\n\\r\\n>It is relevant that the code of the process DataNode dont know the number and the origin of each incoming selections. You can so add and remove origin of  selection without changing the code of the process datanode\\r\\n\\r\\n The PlotlyData datanode used for the histogram takes information from the process node.\\r\\n\\r\\n>A datanode is used to collect information and create the \\\"global\\\" selection. This is not done in the datanode used for plotly data. This global selection could be used for other graphs or script without copy/paste. \\r\\n\\r\\n## How to synchronize selection to have a single global selection\\r\\n\\r\\nThe different selection on each graph are independant.\\r\\n\\r\\nIn some case we want a \\\"global\\\" selection\\\" which regroup all selection and that all graph show the selected data.\\r\\n\\r\\nExample 3\\r\\n\\r\\n* [selection-example-3.xprjson](/wdg/selection/selection-example-3.xprjson)\\r\\n\\r\\nIn this exemple we do 2 scatter plots from the same global data.\\r\\nAs exemple 2, we use a process node to concatenate the information but on both graphs we want to see all the selected data.\\r\\n\\r\\nPlotly graphs are mainly correlated with their own selection. \\r\\n\\r\\n>Trying to use the \\\"selectedpoints\\\" field present in plotly data is a bad idea. This fied is ok if the graph dont has his own selection behavior. But this field is erased when using \\\"rectangle\\\" or \\\"lasso\\\" selection. It is better to consider external selection as a complement of the possible present selection. \\\"appendix II\\\" will enter deeper  in exposing the selection \\r\\n\\r\\nThe additional selected items are not drawn last, so we see clearly a difference between the selection from the graph and the selection from other sources. In next exemple we propose a solution to handle this.\\r\\n \\r\\n## How to use the selection event if the index selected are different from the data index\\r\\n\\r\\nExample 4:\\r\\n* [selection-example-4.xprjson](/wdg/selection/selection-example-4.xprjson)\\r\\n\\r\\nFor the moment, in the different exemples we have assumed that the [index] given by the selection is the same that the index of the data.\\r\\n\\r\\nIt means that if the data selected is \\\"4\\\" it is the same index on the global data index. \\r\\n\\r\\nBut it is not always the case, for multiple reasons, the index given by the selection could be different, for exemple\\r\\n\\r\\n - you need to draw only a part of the data   \\r\\n - you need to sort the data X vs Y in order to draw a line\\r\\n - you need to sort the global data before drawing in order to control\\r\\n   the Z order of the draw\\r\\n - ...\\r\\n\\r\\nEach plotly trace contains a [customdata] field that can help us to resolve this problem\\r\\n\\r\\nIn exemple [nom de l'exemple] we used the same But in the data for plotly DataNode we order the drawn order with all selected data at the end. \\r\\n\\r\\n>it is not possible to give a drawn order to plotly (V2.16.3). The element and the trace are drawn in the order given by the user. Last element of last trace are drawn last.\\r\\n\\r\\nIn the data for plotly Datanode we sort the element but we keep the change in an array called \\\"orderForGraph\\\" which will be transfer to plotly in the \\\"customdata\\\" field. This field is present in the selection of the dataflow and can be used in the selectionProcess node to obtain the equivalent index. \\r\\n\\r\\n## Create a reset selection action\\r\\n\\r\\nExample 5:\\r\\n* [selection-example-5.xprjson](/wdg/selection/selection-example-5.xprjson)\\r\\n\\r\\nin our exemple, selection is in an independant DataNode, and no more only a graphical features. \\r\\n\\r\\nIn order to reset the selection, we need to clean all the DataFlow and all the graphics. In exemple 5 we create a reset selection script which is triggered by a push button. \\r\\n\\r\\n3 significant addition in the dataNode have to be done in order to have a clean result. \\r\\n\\r\\n- Reset the DataNode [Selection] via the xDashApi function. This will reset the selection and the plotly data (done in [ResetSelection] dataNode)\\r\\n- Add the field \\\"selections : []\\\" in all layout impacted in order to remove all the visible rectangle or lasso drawn\\r\\n- Create a relation between the resetSelection action script and the different layout to trigger the layout dataNodes.\\r\\n\\r\\n## Good Practices\\r\\n\\r\\n### Create one datanode for the layout and one for the data\\r\\n\\r\\nIf one dataNode is used to give the Data and the Layout for the widget, some unexpected graphical behavior can happen. \\r\\n\\r\\nUsually data often change according to action, but user like to keep element of visualisation (zoom, factor, element selected, ... )  \\r\\n\\r\\nWhen data changed, plotly will also reset the layout if they are in the same datanode, which can change your view according to what is defined in the original layout. \\r\\n\\r\\n\\r\\n### Never use the same layout DataNode for multiple graphs. \\r\\n\\r\\nPlotly keeps in memory each layout for its own internal use. It never makes copy.\\r\\n\\r\\nIf the same layout is used for exemple for 2 scatter plots each pan/zoom/selection done on one plot ... will be passed to the other graph but not at the same time. \\r\\n\\r\\nThe repercution will be done next time plotly via the dataFlow needs to check the current layout.\\r\\n\\r\\nAnd you dont know when it will happens (often when the widget is selected) \\r\\n\\r\\n  \\r\\n## Appendix 1 : Plotly Selection and xDash Selection\\r\\n\\r\\nStructures of the plotly selection are discribe in \\r\\n\\r\\n[https://plotly.com/javascript/plotlyjs-events/#event-data](https://plotly.com/javascript/plotlyjs-events/#event-data)\\r\\n\\r\\nSo plotly selection events are dependant from the kind of the original graph (2D, 3D, map, ...) \\r\\n \\r\\nPlotly selection cannot directly be transformed in JSON because it is a circular structure.\\r\\n\\r\\nxDash selection event is one unified selection containing an array for each trace which contains the index of the element and the metadata if those one were present in the original trace. \\r\\n\\r\\n[curveNumber (trace number)]\\r\\n - indexSelected : []\\r\\n - customdata : [] (if customdata field is present in original DataTrace)\\r\\n\\r\\nFor exemple if you have 2 traces in your Plotly graph, xDash selection would return :\\r\\n\\r\\n[ 0 : {Data : [1, 10, 120, 123], customData: [1, 10, 120, 123]}]\\r\\n[ 1 : {Data : [1, 10, 120, 123], customData: [1, 10, 120, 123]}]\\r\\n\\r\\n## Appendix 2 : how to handle all selection behaviors from plotly without creating trouble\\r\\n\\r\\nIn some situation you want to have a total control of filter/selection and the way plotly control the selection can create confusion.\\r\\n\\r\\nThe behavior you need can visualy enter in \\\"conflict\\\" with plotly internal behavior, or can provoke non wanted behaviors. \\r\\n\\r\\nWhen you draw a selection via plotly, each attributes dont used the standard fields (color, size, ...) but used the fields that are under the 2 fields \\\"selected\\\" and \\\"unselected\\\" .. and this is true only for plotly graph which accept this fields; \\r\\n\\r\\n\\\"selected\\\" and \\\"unselected\\\" are used by plotly when\\r\\n - a \\\"rectangle\\\" selection is done\\r\\n - a \\\"lasso\\\" selection is done\\r\\n - if the field \\\"selectionpoints\\\" is given as a plotly data\\r\\n\\r\\nIn those cases, data are divided in two groups (selected and unselected) and are drawn according to these fields. If you dont define them, plotly used internal behavior to create them (mainly reducing the tone and the opacity)\\r\\n\\r\\n - the \\\"regular\\\" way (for exemple [data][marker] in scatter plot) to\\r\\n   render graph are no more used when graph is in selection\\r\\n   mode.\\r\\n   \\r\\n - A \\\"rectangle\\\" or \\\"lasso\\\" selection reset the field \\\"selectionpoints\\\"\\r\\n\\r\\nIn exemple 3 and 4 we want to keep the plotly behavior for drawing and moving selection, but we also  want to keep the way we draw things. So we copy the style on the \\\"selected\\\" and \\\"unselected\\\" fields because we want a global selection and not a selection which takes into account only the graph;\\r\\n\",\"isBinary\":false}"
        }
      },
      {
        "name": "df",
        "type": "Python_plugin",
        "settings": {
          "name": "df",
          "autoStart": true,
          "explicitTrig": false,
          "dockerImage": {
            "name": "Pyodide",
            "id": "__PYODIDE__"
          },
          "content": "#example: create 2 datanodes py_a a,d py_b then use them as follow:\n# Example: add the values of 2 datanodes.\n# return dataNodes[\"py_a\"] + dataNodes[\"py_b\"];\nimport pandas as pd\n\nreturn pd.DataFrame({\"A\": [3,3],\"B\": [3,4]})\n"
        }
      },
      {
        "name": "fig",
        "type": "Python_plugin",
        "settings": {
          "name": "fig",
          "autoStart": true,
          "explicitTrig": false,
          "dockerImage": {
            "name": "Pyodide",
            "id": "__PYODIDE__"
          },
          "content": "import plotly.express as px\n\ndf = px.data.gapminder().query(\"country=='Canada'\")\nfig = px.line(df, x=\"year\", y=\"lifeExp\", title='Life expectancy in Canada')\n\nreturn fig\n"
        }
      }
    ]
  },
  "libraries": {
    "pyodideStandard": [
      "pandas"
    ],
    "pyodideMicropip": [
      "plotly"
    ]
  },
  "scaling": {
    "widthPx": 1295,
    "heightPx": 590,
    "scrollWidthPx": 1295,
    "scrollHeightPx": 590,
    "widthVw": 84.75130890052355,
    "heightVh": 78.66666666666667,
    "scrollWidthVw": 84.75130890052355,
    "scrollHeightVh": 78.66666666666667,
    "scalingMethod": "scaleTwh",
    "media": "large",
    "colDims": null
  },
  "device": {
    "cols": {
      "valueRow": "none",
      "valueCol": "1",
      "maxCells": 0,
      "maxCols": 0,
      "classType": ""
    },
    "droppers": {},
    "backgroundColor": "",
    "theme": "default"
  },
  "dashboard": {
    "loadFileA": {
      "layout": {
        "top": "21.0667vh",
        "left": "6.67539vw",
        "height": "15.0667vh",
        "width": "20.0262vw",
        "minHeight": "70px",
        "minWidth": "95px",
        "z-index": "1"
      },
      "container": {
        "instanceId": "loadFileA",
        "modelJsonId": "loadFile"
      },
      "modelParameters": {
        "label": "Choose a file",
        "displayLabel": true,
        "labelFontSize": 0.1,
        "labelColor": "var(--widget-label-color)",
        "labelFontFamily": "var(--widget-font-family)",
        "labelAlign": "left",
        "textColor": "var(--widget-color)",
        "subTextColor": "var(--widget-color)",
        "textSize": 0.1,
        "binaryFileInput": false,
        "displayBorder": true,
        "borderColor": "var(--widget-border-color)",
        "backgroundColor": "var(--widget-dropzone-background-color)",
        "displayBrowseButton": true,
        "labelBackgroundColor": "var(--widget-dropzone-label-background-color)",
        "browseButtonTextColor": "var(--widget-button-text)",
        "browseButtonDefaultColor": "var(--widget-button-color)",
        "browseButtonActiveColor": "var(--widget-button-active-color)",
        "browseButtonHoverColor": "var(--widget-button-hover-color)",
        "deleteButtonDefaultColor": "var(--widget-delete-button-default-color)",
        "deleteButtonActiveColor": "var(--widget-delete-button-active-color)",
        "deleteButtonHoverColor": "var(--widget-delete-button-hover-color)",
        "deleteButtonIconColor": "var(--widget-delete-button-icon-color)",
        "deleteButtonIconHoverColor": "var(--widget-delete-button-icon-hover-color)"
      },
      "modelHiddenParams": {}
    }
  },
  "connections": {
    "loadFileA": {
      "outputFile": {
        "name": "outputFile",
        "dataNode": "a",
        "dataFields": []
      }
    }
  },
  "exportOptions": "ajustToTargetWindow",
  "pages": {
    "pageNames": [],
    "defaultPage": {}
  },
  "checkExportOptions": true,
  "navBarNotification": false
}